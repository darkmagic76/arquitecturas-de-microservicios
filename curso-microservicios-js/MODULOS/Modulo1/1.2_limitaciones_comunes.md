# 1.2 â€“ Limitaciones comunes: escalado, acoplamiento y mantenimiento

---

## ğŸ¯ Objetivo

Identificar las **principales limitaciones de las arquitecturas monolÃ­ticas** y comprender por quÃ© se vuelven problemÃ¡ticas cuando las aplicaciones crecen en funcionalidad, trÃ¡fico o equipos de desarrollo.

---

## ğŸ§© IntroducciÃ³n

Una aplicaciÃ³n monolÃ­tica **funciona muy bien al inicio del proyecto**, pero con el tiempo surgen **problemas estructurales y operativos**.
Estas limitaciones no son evidentes en los primeros meses, pero se hacen crÃ­ticas cuando:

* la base de cÃ³digo crece,
* aumenta el nÃºmero de desarrolladores,
* se necesita escalar solo una parte del sistema.

---

## âš™ï¸ 1. Escalado limitado

En un monolito, **todos los componentes se ejecutan en el mismo proceso**.

Cuando un mÃ³dulo necesita mÃ¡s capacidad (por ejemplo, el de pedidos), **no se puede escalar solo Ã©l**.
Hay que duplicar **toda la aplicaciÃ³n**, aunque el resto de mÃ³dulos no lo necesiten.

### ğŸ”¸ Ejemplo visual

```
[Servidor 1]
 â”œâ”€â”€ /users
 â”œâ”€â”€ /orders
 â”œâ”€â”€ /inventory

Escalado monolÃ­tico â‡’ duplicar todo:
[Servidor 2]
 â”œâ”€â”€ /users
 â”œâ”€â”€ /orders
 â”œâ”€â”€ /inventory
```

â¡ï¸ Resultado: consumo innecesario de recursos, despliegues mÃ¡s lentos y costes mÃ¡s altos.

### ğŸ”¸ En Node.js

```bash
# No se puede ejecutar solo un mÃ³dulo de forma independiente:
node app.js
```

La app completa se levanta aunque solo necesites aumentar `/orders`.

---

## ğŸ§© 2. Acoplamiento fuerte

En los monolitos, los mÃ³dulos estÃ¡n **estrechamente interconectados**:

* Comparten la misma base de datos.
* Se llaman entre sÃ­ directamente.
* Usan los mismos modelos y librerÃ­as.

### ğŸ”¸ Ejemplo de dependencia cruzada

```js
// userService.js
import { createOrder } from './orderService.js';

export function registerUser(name) {
  const user = { name };
  createOrder(user); // dependencia directa
}
```

Si `orderService` cambia, `userService` puede dejar de funcionar.

### ğŸ”¸ Consecuencias

* **Dificultad para probar**: hay que levantar toda la app.
* **Errores en cascada**: un fallo en un mÃ³dulo puede tumbar el sistema completo.
* **DifÃ­cil actualizaciÃ³n tecnolÃ³gica**: cambiar una librerÃ­a afecta a todo el cÃ³digo.

---

## ğŸ§° 3. Mantenimiento complejo

Con el crecimiento del sistema, el cÃ³digo se vuelve **difÃ­cil de entender y modificar**.
Los desarrolladores pierden la visiÃ³n global, y los cambios en un mÃ³dulo pueden generar efectos colaterales inesperados.

### ğŸ”¸ Ejemplo real

> Una aplicaciÃ³n de facturaciÃ³n con cientos de rutas Express, servicios y modelos compartidos.
> Cualquier cambio en â€œclientesâ€ puede romper â€œpedidosâ€ o â€œreportesâ€.

### ğŸ”¸ SÃ­ntomas tÃ­picos

* Commit que rompe funciones no relacionadas.
* Merge conflicts constantes.
* Despliegues que requieren pruebas masivas antes de subir a producciÃ³n.

---

## ğŸš§ Otros problemas derivados

| Ãrea                     | Problema                                                           |
| ------------------------ | ------------------------------------------------------------------ |
| **Despliegue**           | Requiere recompilar todo el artefacto incluso por un cambio menor. |
| **Escalado de equipos**  | Equipos grandes pisan cÃ³digo ajeno. Dificulta el trabajo paralelo. |
| **Fiabilidad**           | Un fallo en un mÃ³dulo (ej. pagos) puede bloquear toda la app.      |
| **Tiempos de respuesta** | El crecimiento del cÃ³digo ralentiza el arranque y las pruebas.     |

---

## ğŸ§  Resumen visual

| LimitaciÃ³n            | Causa raÃ­z                   | Consecuencia                        |
| --------------------- | ---------------------------- | ----------------------------------- |
| Escalado global       | Un Ãºnico bloque de ejecuciÃ³n | Coste y rigidez operativa           |
| Acoplamiento fuerte   | Dependencias entre mÃ³dulos   | Riesgo alto de errores cruzados     |
| Mantenimiento difÃ­cil | CÃ³digo masivo y compartido   | Lentitud en desarrollo y despliegue |

---

## ğŸ’¡ ReflexiÃ³n docente

> Las arquitecturas monolÃ­ticas **se comportan como un Ãºnico organismo**: si una parte enferma, **todo el cuerpo se resiente**.
> Por eso, en la evoluciÃ³n hacia microservicios se busca **independencia funcional y despliegue desacoplado**, para aislar errores, escalar selectivamente y facilitar la evoluciÃ³n del sistema.

---

## ğŸ”š ConclusiÃ³n

Las limitaciones del monolito â€”**escalado global, acoplamiento fuerte y mantenimiento complejo**â€” son las razones principales por las que surgieron **las arquitecturas distribuidas y los microservicios**, tema que se abordarÃ¡ a continuaciÃ³n en el punto **1.3 â€“ IntroducciÃ³n al paradigma distribuido**.