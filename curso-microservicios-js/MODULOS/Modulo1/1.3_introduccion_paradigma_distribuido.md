# 1.3 ‚Äì Introducci√≥n al paradigma distribuido

---

## üéØ Objetivo

Comprender qu√© es una **arquitectura distribuida**, c√≥mo se diferencia de un monolito y por qu√© representa el paso natural hacia los **microservicios** en sistemas modernos que requieren escalabilidad, resiliencia y agilidad en el desarrollo.

---

## üß© ¬øQu√© es una arquitectura distribuida?

Una **arquitectura distribuida** es aquella en la que **las funciones de una aplicaci√≥n est√°n separadas en componentes independientes** que se ejecutan en **procesos o servidores distintos**, pero que **cooperan entre s√≠ mediante comunicaci√≥n por red** (HTTP, gRPC, mensajer√≠a, etc.).

üëâ En lugar de tener **una √∫nica aplicaci√≥n que hace todo**, tenemos **varias piezas m√°s peque√±as**, cada una responsable de una tarea espec√≠fica.

---

## ‚öôÔ∏è Ejemplo visual

**Monolito (todo junto):**

```
[ APP √öNICA ]
 ‚îú‚îÄ‚îÄ /users
 ‚îú‚îÄ‚îÄ /orders
 ‚îú‚îÄ‚îÄ /inventory
 ‚îî‚îÄ‚îÄ /billing
```

**Arquitectura distribuida (cada m√≥dulo independiente):**

```
[ users-service ] ‚Üí gestiona usuarios
[ orders-service ] ‚Üí gestiona pedidos
[ inventory-service ] ‚Üí controla stock
[ billing-service ] ‚Üí maneja pagos
```

Cada servicio tiene su propio ciclo de vida:

* Se despliega por separado.
* Puede tener su propia base de datos.
* Escala de manera independiente.

---

## üîó Comunicaci√≥n entre servicios

Como los servicios ya no viven en el mismo proceso, deben **comunicarse por red**.

### üî∏ Ejemplo con Node.js (comunicaci√≥n REST)

**Servicio de usuarios (`users-service`):**

```js
// users-service/index.js
import express from 'express';
const app = express();

app.get('/users', (req, res) => {
  res.json([{ id: 1, name: 'Ana' }]);
});

app.listen(3001, () => console.log('Users service en puerto 3001'));
```

**Servicio de pedidos (`orders-service`):**

```js
// orders-service/index.js
import express from 'express';
import axios from 'axios';
const app = express();

app.get('/orders', async (req, res) => {
  const { data: users } = await axios.get('http://localhost:3001/users');
  res.json([{ orderId: 100, user: users[0].name, total: 59.90 }]);
});

app.listen(3002, () => console.log('Orders service en puerto 3002'));
```

‚û°Ô∏è Aqu√≠ `orders-service` **consume la API de `users-service`** v√≠a HTTP en lugar de llamar directamente una funci√≥n local.

---

## üß± Principios b√°sicos del paradigma distribuido

| Principio                           | Descripci√≥n                                                          |
| ----------------------------------- | -------------------------------------------------------------------- |
| **Separaci√≥n de responsabilidades** | Cada servicio cubre una parte funcional concreta del negocio.        |
| **Comunicaci√≥n mediante red**       | Los servicios interact√∫an con APIs o colas de mensajes.              |
| **Despliegue independiente**        | Se puede actualizar o reiniciar un servicio sin afectar a los dem√°s. |
| **Escalabilidad selectiva**         | Solo se escalan los componentes que lo requieren.                    |
| **Resiliencia**                     | Un fallo en un servicio no deber√≠a detener todo el sistema.          |

---

## üß† Beneficios clave

| Beneficio                 | Explicaci√≥n                                                        |
| ------------------------- | ------------------------------------------------------------------ |
| **Escalado granular**     | Cada componente puede ajustarse seg√∫n su carga de trabajo.         |
| **Desarrollo paralelo**   | Distintos equipos pueden trabajar en servicios independientes.     |
| **Mantenibilidad**        | C√≥digo m√°s acotado, f√°cil de probar y desplegar.                   |
| **Evoluci√≥n tecnol√≥gica** | Cada servicio puede usar su propio stack (Node.js, Python, Go...). |

---

## ‚ö†Ô∏è Retos de las arquitecturas distribuidas

Aunque solucionan problemas del monolito, tambi√©n introducen nuevos desaf√≠os:

| Desaf√≠o                      | Ejemplo                                                                               |
| ---------------------------- | ------------------------------------------------------------------------------------- |
| **Latencia de red**          | Las llamadas HTTP son m√°s lentas que las llamadas locales.                            |
| **Gesti√≥n de errores**       | Si un servicio no responde, hay que manejar timeouts y reintentos.                    |
| **Coherencia de datos**      | Cada servicio puede tener su propia base de datos ‚Üí surge la ‚Äúconsistencia eventual‚Äù. |
| **Monitoreo y trazabilidad** | Se necesitan herramientas centralizadas de observabilidad.                            |

---

## üîç Analog√≠a docente

> Imagina una empresa:
>
> * En un monolito, **todo el personal trabaja en una misma oficina**.
> * En una arquitectura distribuida, **cada departamento tiene su propia sede**, pero todos **se coordinan mediante comunicaciones**.

Esta divisi√≥n permite crecer m√°s r√°pido, pero requiere **organizaci√≥n, normas y canales eficientes**.

---

## üí¨ Resumen

| Concepto     | Monolito            | Arquitectura distribuida |
| ------------ | ------------------- | ------------------------ |
| Despliegue   | Uno solo            | M√∫ltiples independientes |
| Comunicaci√≥n | Interna (funciones) | Externa (HTTP, eventos)  |
| Escalado     | Global              | Granular                 |
| Fallos       | Propagan f√°cilmente | Aislados por servicio    |
| Tecnolog√≠a   | Uniforme            | Heterog√©nea posible      |

---

## üîö Conclusi√≥n

La arquitectura distribuida es la base conceptual sobre la que se construyen los **microservicios**: una evoluci√≥n del paradigma que combina **modularidad, independencia y resiliencia**.
En el siguiente m√≥dulo comenzaremos a **formalizar el patr√≥n de microservicios**, viendo su estructura, componentes y buenas pr√°cticas.