# 1.1 ‚Äì ¬øQu√© es una arquitectura monol√≠tica?

---

## üéØ Objetivo

Comprender el concepto de **arquitectura monol√≠tica**, sus caracter√≠sticas principales y por qu√© tradicionalmente ha sido el punto de partida para la mayor√≠a de aplicaciones antes de la adopci√≥n de los microservicios.

---

## üß± Definici√≥n general

Una **arquitectura monol√≠tica** es un modelo en el que **toda la l√≥gica de la aplicaci√≥n se encuentra empaquetada en un √∫nico bloque de ejecuci√≥n**.
Esto significa que:

* El **backend, frontend y l√≥gica de negocio** forman parte del mismo proceso.
* Existe **una sola base de datos compartida**.
* Se genera **un √∫nico artefacto desplegable** (por ejemplo, un archivo `.jar`, `.war`, o una app Node ejecutada en un √∫nico servidor).

En otras palabras, **todas las funciones de la aplicaci√≥n viven juntas y se despliegan juntas**.

---

## üß© Estructura t√≠pica

Una aplicaci√≥n monol√≠tica suele tener una estructura similar a la siguiente:

```
üì¶ app/
 ‚îú‚îÄ‚îÄ controllers/
 ‚îú‚îÄ‚îÄ services/
 ‚îú‚îÄ‚îÄ models/
 ‚îú‚îÄ‚îÄ routes/
 ‚îî‚îÄ‚îÄ app.js
```

* `controllers/`: gestionan las peticiones HTTP
* `services/`: contienen la l√≥gica de negocio
* `models/`: interact√∫an con la base de datos
* `app.js`: punto de entrada √∫nico

**Ejemplo conceptual en Node.js (monolito simple):**

```js
import express from 'express';
const app = express();

const users = [{ id: 1, name: "Ana" }, { id: 2, name: "Luis" }];
const orders = [{ id: 100, userId: 1, total: 59.90 }];

// Endpoints mezclados en la misma app
app.get('/users', (req, res) => res.json(users));
app.get('/orders', (req, res) => res.json(orders));

app.listen(3000, () => console.log('Servidor monol√≠tico en puerto 3000'));
```

‚û°Ô∏è Todo el sistema se ejecuta **en un √∫nico servidor y proceso**.
Si una parte falla o necesita escalar, **afecta a todo el conjunto**.

---

## ‚öôÔ∏è Caracter√≠sticas principales

| Aspecto                          | Descripci√≥n                                                                             |
| -------------------------------- | --------------------------------------------------------------------------------------- |
| **Despliegue √∫nico**             | Toda la aplicaci√≥n se construye y despliega como una sola unidad.                       |
| **Base de datos com√∫n**          | Todos los m√≥dulos comparten las mismas tablas y esquemas.                               |
| **Comunicaci√≥n interna directa** | Las funciones se invocan como m√©todos o clases dentro del mismo proceso.                |
| **Mantenimiento centralizado**   | Actualizar o depurar implica volver a desplegar el bloque completo.                     |
| **Dependencias compartidas**     | Las librer√≠as son comunes a toda la app, lo que puede generar conflictos con el tiempo. |

---

## üí¨ Ventajas del enfoque monol√≠tico

* Simplicidad inicial en desarrollo y despliegue.
* No requiere infraestructura distribuida (ideal para prototipos o proyectos peque√±os).
* Pruebas locales sencillas (todo en un solo proceso).
* Depuraci√≥n y logging centralizados.

---

## ‚ö†Ô∏è Desventajas

| Desventaja                               | Impacto                                                                              |
| ---------------------------------------- | ------------------------------------------------------------------------------------ |
| **Dificultad para escalar parcialmente** | Si un m√≥dulo necesita m√°s recursos, se debe escalar toda la app.                     |
| **Acoplamiento fuerte**                  | Los m√≥dulos dependen unos de otros, dificultando la evoluci√≥n independiente.         |
| **Tiempo de despliegue largo**           | Cada cambio requiere recompilar y desplegar todo el bloque.                          |
| **Complejidad en equipos grandes**       | Los desarrolladores pisan c√≥digo de otros, y los ciclos de desarrollo se ralentizan. |
| **Alta dependencia tecnol√≥gica**         | Migrar de framework o base de datos es costoso.                                      |

---

## üß† Reflexi√≥n

> El monolito **no es malo por s√≠ mismo**.
> Es un **modelo adecuado para aplicaciones peque√±as o de bajo tr√°fico**, o cuando se requiere velocidad inicial de desarrollo.
> El problema surge **cuando crece el tama√±o, el equipo y la necesidad de escalar o evolucionar m√≥dulos de forma independiente**.

---

## üîç Conclusi√≥n

Una **arquitectura monol√≠tica** es un √∫nico bloque funcional que facilita el inicio de un proyecto, pero **limita la evoluci√≥n, escalabilidad y resiliencia** a largo plazo.
Este modelo sirve como base para entender por qu√© surgi√≥ la necesidad de **dividir las aplicaciones en microservicios**, tema que se abordar√° en el siguiente punto (**1.2 ‚Äì Limitaciones comunes**).