el la# 2.3 ‚Äì Balanceo y resiliencia

---

## üéØ Objetivo

Comprender c√≥mo las arquitecturas de microservicios gestionan la **distribuci√≥n de carga entre instancias** (balanceo) y c√≥mo aplican **patrones de resiliencia** para sobrevivir a fallos parciales sin comprometer la disponibilidad global del sistema.

---

## üß© Contexto

En un entorno monol√≠tico tradicional, la aplicaci√≥n se ejecuta como un √∫nico proceso:
si falla, el sistema completo se detiene.

En cambio, en una arquitectura distribuida:

* cada microservicio puede tener **m√∫ltiples instancias** activas,
* y la comunicaci√≥n entre ellas puede **redirigirse din√°micamente** seg√∫n disponibilidad o carga.

A esto se le llama **balanceo de carga** (*Load Balancing*).
Pero incluso con balanceo, los fallos son inevitables. Por ello, necesitamos estrategias de **resiliencia**, es decir, la capacidad del sistema de **mantenerse funcional ante errores**.

---

## ‚öñÔ∏è Balanceo de carga

El **balanceo** distribuye las peticiones de entrada entre varias instancias de un mismo servicio para:

* mejorar el rendimiento,
* evitar sobrecargas,
* y garantizar alta disponibilidad.

### üîπ Ejemplo conceptual

Sup√≥n que tienes tres instancias del servicio `users-service`:

```
users-service-1 ‚Üí localhost:3001
users-service-2 ‚Üí localhost:3002
users-service-3 ‚Üí localhost:3003
```

Un balanceador se encarga de decidir a cu√°l enviar cada petici√≥n.
Puede ser un componente dedicado (NGINX, HAProxy) o parte del propio cliente.

---

### üî∏ Ejemplo funcional de balanceo simple (client-side)

Un cliente puede mantener un peque√±o ‚Äúpool‚Äù de instancias y alternar las peticiones:

```js
import axios from "axios";

const instancias = [
  "http://localhost:3001",
  "http://localhost:3002",
  "http://localhost:3003"
];

let indice = 0;

async function obtenerUsuarios() {
  const url = instancias[indice];
  indice = (indice + 1) % instancias.length; // round-robin
  const res = await axios.get(`${url}/users`);
  return res.data;
}

// Cada llamada va a una instancia diferente
```

Este patr√≥n se llama **Round Robin**, y es una forma sencilla de distribuir tr√°fico sin necesidad de un balanceador externo.

En entornos reales, esta funci√≥n la cumplen:

* **Balanceadores externos**: NGINX, AWS ELB, Traefik.
* **Orquestadores**: Kubernetes Services reparten las peticiones autom√°ticamente.
* **API Gateways**: manejan routing y distribuci√≥n de carga de forma centralizada.

---

## üß± Resiliencia

Incluso con balanceo, los servicios pueden fallar:
una instancia puede estar ca√≠da, sobrecargada o devolver errores intermitentes.

La **resiliencia** busca **evitar que los fallos locales se propaguen** al resto del sistema.

Los patrones m√°s usados son:

1. **Retry (reintento)**
2. **Timeout (tiempo m√°ximo de espera)**
3. **Circuit Breaker (disyuntor)**
4. **Bulkhead (compartimentos)**
5. **Fallback (respuesta alternativa)**

Veamos c√≥mo funcionan en la pr√°ctica.

---

### üîπ 1. Retry ‚Äì volver a intentar

Cuando una llamada falla por un error temporal, puede ser suficiente **reintentarla una o dos veces**.

```js
import axios from "axios";

async function llamadaConReintento(url, intentos = 3) {
  for (let i = 0; i < intentos; i++) {
    try {
      const res = await axios.get(url);
      return res.data;
    } catch (e) {
      console.log(`‚ö†Ô∏è Intento ${i + 1} fallido`);
      await new Promise(r => setTimeout(r, 500)); // espera medio segundo
    }
  }
  throw new Error("‚ùå No se pudo conectar tras varios intentos");
}
```

‚úÖ **√ötil para errores transitorios** (latencia, conexiones temporales).

---

### üîπ 2. Timeout ‚Äì no esperar indefinidamente

Si un servicio tarda demasiado en responder, es preferible **interrumpir la petici√≥n** y continuar con una alternativa o un error controlado.

```js
import axios from "axios";

const cliente = axios.create({ timeout: 2000 }); // 2 segundos m√°ximo

try {
  const res = await cliente.get("http://slow-service:3000/data");
  console.log(res.data);
} catch (error) {
  console.error("‚è±Ô∏è Tiempo de espera excedido");
}
```

Esto evita que un servicio lento **bloquee al resto del sistema**.

---

### üîπ 3. Circuit Breaker ‚Äì cortar para proteger

El patr√≥n **Circuit Breaker** (disyuntor) evita sobrecargar un servicio que ya est√° fallando:
si detecta demasiados errores consecutivos, **interrumpe las llamadas durante un tiempo**.

```js
import CircuitBreaker from "opossum";
import axios from "axios";

async function llamadaRemota() {
  const res = await axios.get("http://users-service:3001/users");
  return res.data;
}

const breaker = new CircuitBreaker(llamadaRemota, {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 5000
});

breaker.on("open", () => console.log("üö® Circuito abierto ‚Äì fallos detectados"));
breaker.on("halfOpen", () => console.log("‚ö†Ô∏è Probando recuperaci√≥n"));
breaker.on("close", () => console.log("‚úÖ Circuito cerrado ‚Äì servicio estable"));

const usuarios = await breaker.fire();
```

‚úÖ Cuando el circuito est√° **abierto**, las peticiones fallan r√°pidamente sin intentos innecesarios.
Despu√©s de un tiempo, pasa a **half-open** y prueba si el servicio se ha recuperado.

---

### üîπ 4. Fallback ‚Äì respuesta alternativa

En lugar de fallar por completo, un servicio puede **devolver una respuesta por defecto** si el origen no responde.

```js
async function obtenerUsuariosSeguros() {
  try {
    const res = await axios.get("http://users-service/users");
    return res.data;
  } catch {
    console.log("üü° Usando datos en cach√© por fallo del servicio");
    return [{ id: 0, name: "Usuario temporal" }];
  }
}
```

‚úÖ Esto mantiene el sistema operativo, incluso con datos parciales.

---

### üîπ 5. Bulkhead ‚Äì compartimentos aislados

Inspirado en la ingenier√≠a naval, este patr√≥n divide los recursos (como hilos o conexiones) para evitar que **un fallo en un servicio afecte a los dem√°s**.

Ejemplo conceptual:

* Se usa una **cola separada** o **pool de conexiones** por servicio.
* Si una cola se satura, solo se bloquea ese flujo, no todo el sistema.

```js
// Ejemplo conceptual
const poolUsuarios = new ConnectionPool({ size: 5 });
const poolPedidos = new ConnectionPool({ size: 5 });
```

---

## üí¨ Combinaci√≥n pr√°ctica de resiliencia

Los patrones anteriores suelen **trabajar juntos**.
Un flujo t√≠pico en microservicios podr√≠a verse as√≠:

```
retry ‚Üí timeout ‚Üí circuit breaker ‚Üí fallback
```

Cada capa a√±ade un nivel de protecci√≥n.
Si el servicio no responde, el sistema no se detiene:
reintenta, corta, y devuelve algo √∫til o un mensaje controlado.

---

## üß† Resumen visual

| Patr√≥n              | Prop√≥sito                                   | Resultado                        |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Retry**           | Volver a intentar operaciones fallidas      | Manejo de fallos temporales      |
| **Timeout**         | Limitar el tiempo de espera                 | Evita bloqueos prolongados       |
| **Circuit Breaker** | Interrumpir llamadas repetidamente fallidas | Protege al sistema de sobrecarga |
| **Fallback**        | Respuesta alternativa                       | Mantiene experiencia parcial     |
| **Bulkhead**        | Aislar recursos                             | Previene efectos en cascada      |

---

## ‚öôÔ∏è Balanceo + resiliencia en conjunto

En un entorno real:

* **El balanceador** reparte carga entre instancias activas.
* **Los mecanismos de resiliencia** gestionan las fallas o lentitud de alguna de ellas.
* **Los registros de salud (health checks)** informan al balanceador qu√© instancias deben recibir tr√°fico.

Ejemplo ilustrativo:

```
Cliente ‚Üí Gateway ‚Üí Load Balancer ‚Üí [Instancias saludables]
                                ‚ÜòÔ∏é Circuit Breaker / Retry / Timeout
```

---

## üîö Conclusi√≥n

El balanceo de carga asegura la **distribuci√≥n eficiente del tr√°fico**,
y la resiliencia garantiza la **continuidad del servicio ante fallos**.

Juntos conforman el n√∫cleo de la **robustez operativa** en una arquitectura de microservicios.
Sin ellos, cualquier error local podr√≠a desencadenar una ca√≠da global.