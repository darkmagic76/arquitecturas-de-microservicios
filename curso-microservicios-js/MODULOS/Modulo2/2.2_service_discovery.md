# 2.2 ‚Äì Service Discovery

---

## üéØ Objetivo

Comprender qu√© es el **descubrimiento de servicios (Service Discovery)**, por qu√© es esencial en una arquitectura distribuida, y c√≥mo se puede implementar ‚Äîde forma manual o automatizada‚Äî para permitir que los microservicios **se encuentren y comuniquen sin depender de direcciones fijas**.

---

## üß© Contexto

En un entorno monol√≠tico, todos los m√≥dulos viven dentro del mismo proceso: basta con llamar a una funci√≥n o clase.
En cambio, en una arquitectura de microservicios, cada componente se ejecuta de manera independiente, normalmente en **contenedores** o **m√°quinas diferentes**.

Esto genera una pregunta fundamental:

> üí° ¬øC√≥mo sabe un servicio c√≥mo llegar a otro si su direcci√≥n IP o puerto pueden cambiar constantemente?

En entornos con orquestadores como Kubernetes, los servicios pueden **reiniciarse, escalarse o moverse** entre nodos, lo que hace que **las direcciones sean vol√°tiles**.
Aqu√≠ es donde entra el concepto de **Service Discovery**.

---

## ‚öôÔ∏è Qu√© es Service Discovery

El **Service Discovery** es un mecanismo que permite a los servicios:

1. **Registrarse** cuando se inician (indicando su nombre, IP y puerto).
2. **Descubrir** a otros servicios registrados cuando necesitan comunicarse.

Esto elimina la necesidad de **configurar direcciones manualmente** en el c√≥digo.

---

### üîç Ejemplo conceptual

Sin Service Discovery:

```js
// Direcci√≥n fija ‚Äî fr√°gil
const users = await axios.get("http://localhost:3001/users");
```

Si el servicio `users` se mueve a otro host o puerto, esta l√≠nea falla.

Con Service Discovery:

```js
// Resoluci√≥n din√°mica
const host = await discovery.lookup("users-service");
const users = await axios.get(`http://${host}/users`);
```

El servicio `orders` ya no necesita conocer la ubicaci√≥n exacta, solo el **nombre l√≥gico del servicio**.

---

## üß† Enfoques de descubrimiento

Hay dos estrategias principales:

| Estrategia                | Descripci√≥n                                                                                    | Ejemplo                             |
| ------------------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------- |
| **Client-side discovery** | El cliente consulta directamente el registro para encontrar la direcci√≥n del servicio destino. | Netflix Eureka, Consul              |
| **Server-side discovery** | Un *load balancer* o *gateway* se encarga de redirigir las peticiones al servicio adecuado.    | NGINX, AWS ELB, Kubernetes Services |

---

## üîß Ejemplo funcional simplificado (Client-side Discovery)

Imaginemos un sistema con un **registro de servicios simple** almacenado en memoria.
Cada microservicio se registra al iniciar, y otros pueden consultar este registro.

### Registro de servicios

```js
// registry.js
const servicios = new Map();

export function registrar(nombre, host, puerto) {
  servicios.set(nombre, { host, puerto });
  console.log(`üóÇÔ∏è Servicio registrado: ${nombre} (${host}:${puerto})`);
}

export function resolver(nombre) {
  return servicios.get(nombre);
}
```

### Servicio que se registra

```js
// users-service
import { registrar } from "./registry.js";
registrar("users-service", "localhost", 3001);
```

### Servicio que descubre y consulta

```js
// orders-service
import axios from "axios";
import { resolver } from "./registry.js";

async function obtenerUsuarios() {
  const servicio = resolver("users-service");
  const url = `http://${servicio.host}:${servicio.puerto}/users`;
  const res = await axios.get(url);
  console.log("Usuarios disponibles:", res.data);
}
```

Este esquema demuestra el principio fundamental:
cada servicio **se anuncia** al iniciarse, y los dem√°s pueden **descubrirlo din√°micamente**.

---

## üß± Service Discovery en sistemas reales

En entornos de producci√≥n, este registro no se implementa a mano, sino que se delega en **herramientas especializadas**:

| Herramienta                   | Funci√≥n                                                 | Ejemplo de uso                                   |
| ----------------------------- | ------------------------------------------------------- | ------------------------------------------------ |
| **Consul**                    | Registro clave-valor y descubrimiento v√≠a HTTP/DNS      | `consul catalog services`                        |
| **Eureka (Netflix OSS)**      | Registro din√°mico con health checks integrados          | `eureka.client.serviceUrl.defaultZone`           |
| **Kubernetes DNS / Services** | Descubrimiento autom√°tico mediante nombres DNS internos | `http://users-service.default.svc.cluster.local` |

Ejemplo en Kubernetes:

```bash
# Un pod puede resolver la IP de otro servicio
curl http://orders-service.default.svc.cluster.local
```

Kubernetes act√∫a como sistema de **Service Discovery nativo**, gestionando IPs, balanceo y nombres de servicio autom√°ticamente.

---

## üß© Integraci√≥n con comunicaci√≥n s√≠ncrona y as√≠ncrona

* En **REST**, el descubrimiento garantiza que cada servicio encuentre al otro por nombre sin depender de IPs.
* En **mensajer√≠a**, el broker (Kafka, RabbitMQ, etc.) act√∫a como **punto central de descubrimiento**, gestionando colas y t√≥picos registrados.

Ejemplo conceptual de consumidor din√°mico en RabbitMQ:

```js
// Se conecta a la cola publicada en el registro
const queueName = discovery.lookup("cola_pedidos");
channel.consume(queueName, (msg) => { ... });
```

---

## ‚ö†Ô∏è Retos y consideraciones

| Desaf√≠o                        | Descripci√≥n                                                                   |
| ------------------------------ | ----------------------------------------------------------------------------- |
| **Consistencia**               | El registro debe reflejar el estado real de los servicios (alive/dead).       |
| **Escalado din√°mico**          | Cuando un servicio tiene varias instancias, el registro debe actualizarlas.   |
| **Latencia de descubrimiento** | La b√∫squeda de direcciones no debe a√±adir retraso significativo.              |
| **Seguridad**                  | No todos los servicios deben descubrir todos los dem√°s (autenticaci√≥n, ACLs). |

---

## üß† Buenas pr√°cticas

1. **Centralizar el registro** en un servicio confiable (Eureka, Consul, Kubernetes).
2. **Agregar health checks** peri√≥dicos para limpiar instancias inactivas.
3. **Evitar configuraciones est√°ticas** en c√≥digo: usar nombres de servicio, no IPs.
4. **Integrar cach√© local** para no consultar el registro en cada llamada.
5. **Monitorear el registro**: un Service Discovery ca√≠do puede afectar todo el sistema.

---

## üí¨ Resumen

* El **Service Discovery** permite que los microservicios **se localicen autom√°ticamente** sin direcciones fijas.
* Existen dos modelos principales: *client-side* y *server-side*.
* Herramientas como **Consul, Eureka o Kubernetes** simplifican este proceso.
* Su correcta implementaci√≥n es clave para el **despliegue din√°mico y la resiliencia** en entornos distribuidos.

---

## üîö Conclusi√≥n

El descubrimiento de servicios es el ‚ÄúGPS‚Äù de una arquitectura distribuida:
sin √©l, los microservicios no podr√≠an encontrarse en un entorno cambiante.
En el siguiente apartado, exploraremos c√≥mo asegurar que esta comunicaci√≥n sea **tolerante a fallos y eficiente**, mediante **balanceo de carga y patrones de resiliencia**.