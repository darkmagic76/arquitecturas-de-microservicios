## üß± Estructura recomendada

```
curso-microservicios-js/
‚îî‚îÄ‚îÄ LABS/
    ‚îî‚îÄ‚îÄ resiliencia/
        ‚îú‚îÄ‚îÄ docker-compose.yml
        ‚îú‚îÄ‚îÄ unreliable-service/
        ‚îÇ   ‚îî‚îÄ‚îÄ index.js
        ‚îî‚îÄ‚îÄ client-service/
            ‚îî‚îÄ‚îÄ index.js
```

---

## üê≥ docker-compose.yml

Guarda este archivo en:
`curso-microservicios-js/LABS/resiliencia/docker-compose.yml`

```yaml
version: "3.9"

services:
  # Servicio inestable que simula fallos, lentitud y publica eventos
  unreliable-service:
    image: node:22
    container_name: unreliable-service
    working_dir: /app
    volumes:
      - ./unreliable-service:/app
    command: bash -c "npm install express amqplib && node index.js"
    ports:
      - "4000:4000"
    environment:
      - NODE_ENV=development
      - RABBITMQ_URL=amqp://rabbitmq
    depends_on:
      - rabbitmq

  # Servicio cliente que aplica patrones de resiliencia y consume mensajes
  client-service:
    image: node:22
    container_name: client-service
    working_dir: /app
    volumes:
      - ./client-service:/app
    command: bash -c "npm install express axios opossum amqplib && node index.js"
    ports:
      - "4001:4001"
    environment:
      - NODE_ENV=development
      - RABBITMQ_URL=amqp://rabbitmq
      - UNRELIABLE_URL=http://unreliable-service:4000
    depends_on:
      - unreliable-service
      - rabbitmq

  # Broker RabbitMQ con interfaz web (15672)
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
```

---

## ‚öôÔ∏è unreliable-service/index.js

Guarda este archivo en:
`curso-microservicios-js/LABS/resiliencia/unreliable-service/index.js`

```js
import express from "express";
import amqp from "amqplib";

const app = express();
app.use(express.json());

const PORT = 4000;
const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

let channel;

// conexi√≥n RabbitMQ compartida
async function getChannel() {
  if (channel) return channel;
  const conn = await amqp.connect(RABBITMQ_URL);
  channel = await conn.createChannel();
  await channel.assertQueue("pedidos_creados", { durable: true });
  console.log("üì° Conectado a RabbitMQ y cola asegurada");
  return channel;
}

// endpoint inestable
app.get("/sometimes-fails", (req, res) => {
  if (Math.random() < 0.5) {
    console.log("‚ùå /sometimes-fails fall√≥");
    return res.status(500).json({ error: "Fallo aleatorio" });
  }
  console.log("‚úÖ /sometimes-fails OK");
  res.json({ message: "OK" });
});

// endpoint lento
app.get("/slow", (req, res) => {
  console.log("‚è±Ô∏è /slow iniciando...");
  setTimeout(() => res.json({ message: "Respuesta lenta tras 5s" }), 5000);
});

// endpoint estable
app.get("/always-ok", (req, res) => {
  res.json({ message: "Siempre OK" });
});

// simula creaci√≥n de pedido y publica evento RabbitMQ
app.post("/orders", async (req, res) => {
  const pedido = { id: Date.now(), user: req.body.user || "An√≥nimo" };
  console.log(`üßæ Pedido recibido: ${pedido.id}`);
  const ch = await getChannel();
  ch.sendToQueue("pedidos_creados", Buffer.from(JSON.stringify(pedido)));
  console.log("üì§ Evento enviado a cola 'pedidos_creados'");
  res.json({ status: "ok", pedido });
});

app.listen(PORT, () => {
  console.log(`üö® Unreliable Service en http://unreliable-service:${PORT}`);
});
```

---

## ‚öôÔ∏è client-service/index.js

Guarda este archivo en:
`curso-microservicios-js/LABS/resiliencia/client-service/index.js`

```js
import express from "express";
import axios from "axios";
import CircuitBreaker from "opossum";
import amqp from "amqplib";

const app = express();
const PORT = 4001;

const BASE = process.env.UNRELIABLE_URL || "http://unreliable-service:4000";
const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

/* ============================================================
   üîπ 1. LLAMADA B√ÅSICA
   ============================================================ */
app.get("/test/basic", async (req, res) => {
  try {
    const { data } = await axios.get(`${BASE}/sometimes-fails`);
    res.json({ patron: "basic", resultado: data });
  } catch {
    res.status(500).json({ patron: "basic", error: "fallo remoto" });
  }
});

/* ============================================================
   üîπ 2. RETRY
   ============================================================ */
async function callWithRetry(url, retries = 3, delay = 500) {
  for (let i = 1; i <= retries; i++) {
    try {
      console.log(`üîÅ Intento ${i}...`);
      const { data } = await axios.get(url);
      return data;
    } catch (e) {
      if (i === retries) throw e;
      await new Promise(r => setTimeout(r, delay));
    }
  }
}

app.get("/test/retry", async (req, res) => {
  try {
    const data = await callWithRetry(`${BASE}/sometimes-fails`, 3, 500);
    res.json({ patron: "retry", resultado: data });
  } catch {
    res.status(500).json({ patron: "retry", error: "todos los intentos fallaron" });
  }
});

/* ============================================================
   üîπ 3. TIMEOUT
   ============================================================ */
const http = axios.create({ timeout: 2000 }); // 2 segundos m√°x

app.get("/test/timeout", async (req, res) => {
  try {
    const { data } = await http.get(`${BASE}/slow`);
    res.json({ patron: "timeout", resultado: data });
  } catch {
    res.status(504).json({ patron: "timeout", error: "tiempo excedido" });
  }
});

/* ============================================================
   üîπ 4. CIRCUIT BREAKER
   ============================================================ */
async function llamadaRemota() {
  const { data } = await axios.get(`${BASE}/sometimes-fails`);
  return data;
}

const breaker = new CircuitBreaker(llamadaRemota, {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 5000
});

breaker.on("open", () => console.log("üö® Circuito ABIERTO"));
breaker.on("halfOpen", () => console.log("‚ö†Ô∏è Circuito HALF-OPEN"));
breaker.on("close", () => console.log("‚úÖ Circuito CERRADO"));

app.get("/test/circuit-breaker", async (req, res) => {
  try {
    const data = await breaker.fire();
    res.json({ patron: "circuit-breaker", resultado: data });
  } catch {
    res.status(503).json({ patron: "circuit-breaker", error: "circuito abierto o fallo remoto" });
  }
});

/* ============================================================
   üîπ 5. FALLBACK
   ============================================================ */
let cache = [{ id: 0, name: "usuario cacheado" }];

async function getWithFallback() {
  try {
    const { data } = await axios.get(`${BASE}/sometimes-fails`);
    cache = [data];
    return { origen: "remoto", data };
  } catch {
    return { origen: "fallback", data: cache };
  }
}

app.get("/test/fallback", async (req, res) => {
  const result = await getWithFallback();
  res.json({ patron: "fallback", resultado: result });
});

/* ============================================================
   üîπ 6. CONSUMIDOR AS√çNCRONO RABBITMQ
   ============================================================ */
async function listenRabbit() {
  try {
    const conn = await amqp.connect(RABBITMQ_URL);
    const ch = await conn.createChannel();
    await ch.assertQueue("pedidos_creados", { durable: true });
    console.log("üì• Escuchando cola 'pedidos_creados'...");
    ch.consume("pedidos_creados", msg => {
      const pedido = JSON.parse(msg.content.toString());
      console.log(`üßæ [Factura] Pedido recibido: ${pedido.id} de ${pedido.user}`);
      ch.ack(msg);
    });
  } catch (e) {
    console.error("‚ùå Error conectando a RabbitMQ:", e.message);
  }
}

listenRabbit();

/* ============================================================
   üöÄ START
   ============================================================ */
app.listen(PORT, () => {
  console.log(`üß™ Client Service en http://client-service:${PORT}`);
  console.log("Endpoints disponibles:");
  console.log("  - /test/basic");
  console.log("  - /test/retry");
  console.log("  - /test/timeout");
  console.log("  - /test/circuit-breaker");
  console.log("  - /test/fallback");
});
```

---

## ‚ñ∂Ô∏è C√≥mo ejecutarlo

Desde tu Codespace o terminal:

```bash
cd curso-microservicios-js/LABS/resiliencia
docker compose up
```

---

## üß™ C√≥mo probarlo

### 1Ô∏è‚É£ Resiliencia (cliente ‚Üí servicio inestable)

```http
GET http://localhost:4001/test/basic
GET http://localhost:4001/test/retry
GET http://localhost:4001/test/timeout
GET http://localhost:4001/test/circuit-breaker
GET http://localhost:4001/test/fallback
```

Mira los logs en consola del cliente (`client-service`) para observar c√≥mo act√∫a cada patr√≥n.

---

### 2Ô∏è‚É£ Mensajer√≠a (comunicaci√≥n as√≠ncrona)

Env√≠a un pedido (desde Postman o REST Client):

```http
POST http://localhost:4000/orders
Content-Type: application/json

{
  "user": "David"
}
```

Y observa en los logs del cliente:

```
üßæ [Factura] Pedido recibido: 1730744123919 de David
```

‚úÖ Esto demuestra la comunicaci√≥n as√≠ncrona por RabbitMQ entre los dos microservicios.

---

### 3Ô∏è‚É£ RabbitMQ Web UI

Accede a la interfaz en tu navegador:

```
http://localhost:15672
```

Usuario: `guest`
Contrase√±a: `guest`

All√≠ ver√°s la cola **`pedidos_creados`** creciendo y vaci√°ndose al ser consumida.

---

## üß† Qu√© est√°s aprendiendo con este laboratorio

* Comunicaci√≥n **s√≠ncrona** (REST entre servicios Docker).
* Comunicaci√≥n **as√≠ncrona** (RabbitMQ entre servicios).
* Patrones de **resiliencia**: retry, timeout, circuit breaker, fallback.
* **Networking Docker Compose**: comunicaci√≥n por nombres de servicio.
* Integraci√≥n realista de **mensajer√≠a + microservicios Node.js**.