# 2.1 ‚Äì Comunicaci√≥n entre servicios

---

## üéØ Objetivo

Comprender c√≥mo los microservicios se comunican entre s√≠ dentro de una arquitectura distribuida, tanto de forma **s√≠ncrona (REST)** como **as√≠ncrona (mensajer√≠a)**, y analizar los efectos que cada enfoque tiene sobre el rendimiento, la independencia y la resiliencia del sistema.

---

## üß© Contexto

En una arquitectura de microservicios, cada servicio es **independiente y aut√≥nomo**, pero rara vez funciona aislado.
El valor real surge cuando varios servicios **colaboran entre s√≠** para cubrir un flujo de negocio completo: usuarios, pedidos, inventario, pagos‚Ä¶

A diferencia del monolito, donde los m√≥dulos comparten memoria o llamadas de funci√≥n, los microservicios **se comunican a trav√©s de la red**.
Esto introduce nuevas posibilidades ‚Äîy nuevos retos‚Äî en t√©rminos de latencia, disponibilidad y consistencia.

---

## üîó Tipos de comunicaci√≥n

Los microservicios pueden intercambiar informaci√≥n de dos formas fundamentales:

| Tipo          | Caracter√≠sticas                                                                       | Ejemplo t√≠pico                    |
| ------------- | ------------------------------------------------------------------------------------- | --------------------------------- |
| **S√≠ncrona**  | El servicio A llama al servicio B y **espera su respuesta**.                          | REST, gRPC                        |
| **As√≠ncrona** | El servicio A **env√≠a un mensaje** y contin√∫a su ejecuci√≥n; B lo procesar√° m√°s tarde. | RabbitMQ, Kafka, colas de eventos |

---

## ‚öôÔ∏è Comunicaci√≥n s√≠ncrona (REST)

La comunicaci√≥n s√≠ncrona es la m√°s intuitiva: un servicio **invoca una API HTTP** de otro servicio, espera la respuesta y contin√∫a.
Este modelo se utiliza cuando la informaci√≥n es inmediata o esencial para completar la operaci√≥n.

---

### üîπ Ejemplo conceptual: servicio de pedidos que consulta usuarios

Imaginemos dos microservicios:

* `users-service`: gestiona los usuarios registrados.
* `orders-service`: gestiona los pedidos y necesita conocer los datos del usuario que los realiza.

```js
// Servicio de pedidos
import axios from "axios";

async function crearPedido(userId, productos) {
  // Llamada HTTP a otro microservicio
  const usuario = await axios.get(`http://users-service:3001/users/${userId}`);

  const pedido = {
    id: Date.now(),
    user: usuario.data.name,
    productos,
    total: productos.reduce((s, p) => s + p.precio, 0)
  };

  console.log(`üßæ Pedido creado para ${pedido.user}: ${pedido.total} ‚Ç¨`);
  return pedido;
}
```

**Qu√© ocurre:**

* El servicio `orders` realiza una llamada a `users` y **espera la respuesta**.
* Si `users-service` est√° ca√≠do o responde lento, el flujo completo se bloquea.

Este patr√≥n es simple pero introduce **acoplamiento temporal**: el √©xito de una operaci√≥n depende de la disponibilidad del servicio remoto.

---

### üîç Implicaciones del modelo s√≠ncrono

| Ventajas                                           | Inconvenientes                                                          |
| -------------------------------------------------- | ----------------------------------------------------------------------- |
| Comunicaci√≥n directa, f√°cil de entender.           | Acoplamiento fuerte: un servicio depende de la disponibilidad del otro. |
| Ideal para operaciones de lectura o validaci√≥n.    | Introduce latencia y riesgo de fallo en cascada.                        |
| Compatible con herramientas est√°ndar (HTTP, JSON). | Requiere manejo de errores, timeouts y reintentos.                      |

Ejemplo de manejo b√°sico de error:

```js
try {
  const res = await axios.get("http://users-service/users");
  return res.data;
} catch (error) {
  console.error("‚ùå No se pudo conectar con users-service:", error.message);
  return { error: "Servicio temporalmente no disponible" };
}
```

---

## üïäÔ∏è Comunicaci√≥n as√≠ncrona (mensajer√≠a)

Cuando los servicios deben **intercambiar informaci√≥n sin depender de la respuesta inmediata del otro**, se utiliza **mensajer√≠a as√≠ncrona** mediante un *broker* (intermediario).

En este modelo:

1. Un servicio **publica un mensaje** en una cola o t√≥pico.
2. Otro servicio **suscrito** lo recibe y lo procesa m√°s tarde.
3. No existe bloqueo entre ambos: cada uno trabaja a su ritmo.

---

### üîπ Ejemplo conceptual: RabbitMQ como bus de eventos

Imaginemos que, cada vez que se crea un pedido, queremos notificar a otros servicios (como facturaci√≥n o env√≠o).
No necesitamos respuesta inmediata; basta con **publicar un evento ‚Äúpedido_creado‚Äù** que otros escuchen.

#### Emisor (servicio de pedidos)

```js
import amqp from "amqplib";

async function publicarPedido(pedido) {
  const conn = await amqp.connect("amqp://localhost");
  const canal = await conn.createChannel();
  const cola = "pedidos_creados";

  await canal.assertQueue(cola, { durable: true });
  canal.sendToQueue(cola, Buffer.from(JSON.stringify(pedido)));

  console.log(`üì§ Pedido publicado: ${pedido.id}`);
  await canal.close();
  await conn.close();
}
```

#### Receptor (servicio de facturaci√≥n)

```js
import amqp from "amqplib";

async function escucharPedidos() {
  const conn = await amqp.connect("amqp://localhost");
  const canal = await conn.createChannel();
  const cola = "pedidos_creados";

  await canal.assertQueue(cola, { durable: true });
  console.log("üì• Esperando eventos de pedidos...");

  canal.consume(cola, (msg) => {
    const pedido = JSON.parse(msg.content.toString());
    console.log(`üßæ Generando factura para pedido ${pedido.id}`);
    canal.ack(msg);
  });
}
```

---

### üîç Qu√© aporta este modelo

* **Desacoplamiento temporal:** el emisor no depende del consumidor.
* **Resiliencia:** si un servicio est√° ca√≠do, el mensaje queda en cola.
* **Escalabilidad natural:** m√∫ltiples consumidores pueden procesar en paralelo.

Sin embargo, tambi√©n introduce **complejidad operativa**:

* Hay que gestionar el *broker* (RabbitMQ, Kafka, etc.).
* Se requiere control de reintentos, duplicados y orden de mensajes.
* No hay respuesta inmediata; la confirmaci√≥n es eventual.

---

## üß† Comparativa entre comunicaci√≥n s√≠ncrona y as√≠ncrona

| Aspecto                  | S√≠ncrona (REST)                  | As√≠ncrona (mensajer√≠a)             |
| ------------------------ | -------------------------------- | ---------------------------------- |
| **Dependencia temporal** | Alta (bloqueante)                | Baja (no bloqueante)               |
| **Latencia percibida**   | Inmediata                        | Diferida                           |
| **Acoplamiento**         | Fuerte                           | D√©bil                              |
| **Complejidad t√©cnica**  | Menor                            | Mayor                              |
| **Escalabilidad**        | Limitada por el servicio remoto  | Natural con colas                  |
| **Uso t√≠pico**           | Validaciones, consultas directas | Eventos, notificaciones, pipelines |

---

## üß© Buenas pr√°cticas

1. **Combinar ambos modelos** seg√∫n el caso de uso:

   * REST para interacciones inmediatas.
   * Mensajer√≠a para procesos desacoplados o notificaciones.

2. **Documentar los contratos** de comunicaci√≥n (endpoints o tipos de mensaje).

3. **Asegurar idempotencia** en los consumidores as√≠ncronos para evitar duplicados.

4. **Implementar trazabilidad** (correlation IDs) para seguir flujos entre servicios.

5. **Simular fallos** de red o ca√≠das para probar la resiliencia de ambos modelos.

---

## üí¨ Resumen

* La comunicaci√≥n entre microservicios puede ser **s√≠ncrona o as√≠ncrona**.
* La **s√≠ncrona** es inmediata pero dependiente de la disponibilidad del otro servicio.
* La **as√≠ncrona** permite independencia temporal mediante un *broker* (RabbitMQ/Kafka).
* Entender cu√°ndo usar cada modelo es esencial para dise√±ar sistemas escalables y resilientes.
* La combinaci√≥n de ambos patrones es lo que da flexibilidad real a una arquitectura distribuida moderna.

---

## üîö Conclusi√≥n

La comunicaci√≥n entre servicios define el ‚Äúsistema nervioso‚Äù de los microservicios.
Su dise√±o impacta directamente en la **agilidad, escalabilidad y resiliencia** del sistema.
En los siguientes apartados profundizaremos en los mecanismos que ayudan a **gestionar esta comunicaci√≥n de forma autom√°tica y segura**, como el **Service Discovery** y los **patrones de resiliencia**.
