# 3.3 ‚Äì Coreograf√≠a vs Orquestaci√≥n en sistemas distribuidos

---

## üéØ Objetivo

Entender los dos enfoques principales para coordinar flujos de negocio en arquitecturas distribuidas basadas en microservicios:

* **Coreograf√≠a**: la coordinaci√≥n se hace **por eventos**, sin un ‚Äújefe‚Äù central.
* **Orquestaci√≥n**: un servicio **orquestador** controla el flujo y decide qu√© servicio hace qu√© y cu√°ndo.

Veremos:

* Definici√≥n de cada enfoque.
* Diagramas de flujo con **Mermaid**.
* Ejemplos funcionales en JavaScript (Node.js), usando HTTP y eventos (RabbitMQ).

---

## üß© El problema: ¬øqui√©n coordina el flujo?

En un monolito, los flujos de negocio se coordinan dentro del mismo proceso:

```js
function procesarPedido(pedido) {
  validarPedido(pedido);
  cobrar(pedido);
  prepararEnvio(pedido);
  enviarEmailConfirmacion(pedido);
}
```

En microservicios, cada una de esas piezas puede vivir en un servicio distinto:

* `orders-service`
* `payments-service`
* `shipping-service`
* `notifications-service`

La pregunta es:

> ¬øQui√©n decide el orden y la l√≥gica de este flujo?

Las dos respuestas cl√°sicas son: **coreograf√≠a** y **orquestaci√≥n**.

---

## üï∫ Coreograf√≠a: ‚Äúcada servicio sabe su parte‚Äù

En la **coreograf√≠a**, no existe un coordinador central.
Cada servicio **reacciona a eventos** y, si es necesario, **emite nuevos eventos** para que otros reaccionen.

üëâ El flujo se construye como una especie de ‚Äúbaile‚Äù donde todos saben **cu√°ndo entrar** y **qu√© hacer**, pero no hay un director.

---

### üîπ Ejemplo de flujo coreografiado

1. `orders-service` emite `pedido_creado`.
2. `payments-service` escucha `pedido_creado` ‚Üí intenta cobrar ‚Üí emite `pago_confirmado`.
3. `shipping-service` escucha `pago_confirmado` ‚Üí prepara el env√≠o ‚Üí emite `pedido_enviado`.
4. `notifications-service` escucha `pedido_enviado` ‚Üí manda correo al cliente.

### üß≠ Diagrama coreografiado (Mermaid)

```mermaid
sequenceDiagram
  participant C as Cliente
  participant O as Orders Service
  participant BUS as Event Bus
  participant P as Payments Service
  participant S as Shipping Service
  participant N as Notifications Service

  C->>O: POST /pedido
  O-->>BUS: Evento "pedido_creado"
  BUS-->>P: "pedido_creado"
  P-->>BUS: Evento "pago_confirmado"
  BUS-->>S: "pago_confirmado"
  S-->>BUS: Evento "pedido_enviado"
  BUS-->>N: "pedido_enviado"
  N-->>C: Email confirmaci√≥n enviado
```

No hay un ‚Äúservicio central‚Äù que coordine todo.
Cada servicio escucha eventos relevantes y act√∫a.

---

### üîπ Ejemplo funcional (coreograf√≠a con RabbitMQ)

> Nota: se asume que hay un bus tipo RabbitMQ accesible como `amqp://rabbitmq`.

#### `payments-service` (reacciona a `pedido_creado` y emite `pago_confirmado`)

```js
import amqp from "amqplib";

async function startPaymentsService() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const exchange = "eventos";
  await ch.assertExchange(exchange, "topic", { durable: true });

  const q = await ch.assertQueue("payments-service");
  await ch.bindQueue(q.queue, exchange, "pedido.creado");

  console.log("üí≥ Payments Service escuchando 'pedido.creado'...");

  ch.consume(q.queue, async msg => {
    const evento = JSON.parse(msg.content.toString());
    console.log("üí≥ Procesando pago para pedido", evento.data.id);

    // Simular pago OK
    const eventoPago = {
      tipo: "pago_confirmado",
      data: { pedidoId: evento.data.id, cliente: evento.data.cliente }
    };

    ch.publish(exchange, "pago.confirmado", Buffer.from(JSON.stringify(eventoPago)));
    console.log("üì§ Evento 'pago_confirmado' publicado");

    ch.ack(msg);
  });
}

startPaymentsService();
```

#### `shipping-service` (reacciona a `pago_confirmado`)

```js
import amqp from "amqplib";

async function startShippingService() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const exchange = "eventos";
  await ch.assertExchange(exchange, "topic", { durable: true });

  const q = await ch.assertQueue("shipping-service");
  await ch.bindQueue(q.queue, exchange, "pago.confirmado");

  console.log("üì¶ Shipping Service escuchando 'pago_confirmado'...");

  ch.consume(q.queue, msg => {
    const evento = JSON.parse(msg.content.toString());
    console.log("üì¶ Preparando env√≠o para pedido", evento.data.pedidoId);
    ch.ack(msg);
  });
}

startShippingService();
```

üëâ Aqu√≠ no hay orquestador. El **bus de eventos** m√°s las reglas de suscripci√≥n construyen el flujo.

---

### ‚úÖ Ventajas de la coreograf√≠a

* **Menos acoplamiento central**: no hay un ‚Äúmega servicio‚Äù que lo controle todo.
* **Alta extensibilidad**: nuevos servicios pueden suscribirse a eventos sin cambiar los existentes.
* Ideal para **event-driven architectures**.

### ‚ö†Ô∏è Inconvenientes

* Dif√≠cil de ver el **flujo completo**: la l√≥gica se reparte entre m√∫ltiples servicios.
* Riesgo de ‚Äúbaile descontrolado‚Äù si cada servicio emite eventos sin una estrategia clara.
* Debug m√°s complejo: hay que rastrear eventos a trav√©s de varios servicios.

---

## üéõÔ∏è Orquestaci√≥n: ‚Äúun director que coordina todo‚Äù

En la **orquestaci√≥n**, existe un **servicio orquestador** que:

* Decide el orden del flujo.
* Llama a cada servicio (normalmente por HTTP o mensajes directos).
* Contiene la ‚Äúcoreograf√≠a‚Äù como c√≥digo centralizado.

üëâ Piensa en una API BFF (Backend for Frontend) o en un **saga orchestrator**.

---

### üîπ Ejemplo de flujo orquestado

1. `orchestrator-service` recibe la petici√≥n de crear pedido.
2. Llama a `orders-service` para crear el pedido.
3. Llama a `payments-service` para cobrar.
4. Llama a `shipping-service` para enviar.
5. Llama a `notifications-service` para mandar el email.

### üß≠ Diagrama orquestado (Mermaid)

```mermaid
sequenceDiagram
  participant C as Cliente
  participant ORC as Orchestrator
  participant O as Orders Service
  participant P as Payments Service
  participant S as Shipping Service
  participant N as Notifications Service

  C->>ORC: POST /procesar-pedido
  ORC->>O: POST /pedidos
  O-->>ORC: Pedido creado
  ORC->>P: POST /pagar
  P-->>ORC: Pago OK
  ORC->>S: POST /enviar
  S-->>ORC: Env√≠o OK
  ORC->>N: POST /notificar
  N-->>ORC: Email OK
  ORC-->>C: Flujo completado
```

El **orquestador** controla el flujo de principio a fin.

---

### üîπ Ejemplo funcional (orquestaci√≥n con HTTP)

#### Orchestrator

```js
import express from "express";
import axios from "axios";

const app = express();
app.use(express.json());

const ORDERS_URL = "http://orders-service:3000";
const PAYMENTS_URL = "http://payments-service:3001";
const SHIPPING_URL = "http://shipping-service:3002";
const NOTIFICATIONS_URL = "http://notifications-service:3003";

app.post("/procesar-pedido", async (req, res) => {
  try {
    const { cliente, productos } = req.body;

    // 1. Crear pedido
    const pedidoRes = await axios.post(`${ORDERS_URL}/pedidos`, { cliente, productos });
    const pedido = pedidoRes.data;

    // 2. Cobrar
    await axios.post(`${PAYMENTS_URL}/pagar`, { pedidoId: pedido.id, total: pedido.total });

    // 3. Preparar env√≠o
    await axios.post(`${SHIPPING_URL}/enviar`, { pedidoId: pedido.id, direccion: pedido.direccion });

    // 4. Notificar
    await axios.post(`${NOTIFICATIONS_URL}/email-confirmacion`, { pedidoId: pedido.id, cliente });

    res.json({ status: "ok", pedidoId: pedido.id });
  } catch (error) {
    console.error("‚ùå Error en orquestaci√≥n:", error.message);
    res.status(500).json({ error: "Fallo en el flujo orquestado" });
  }
});

app.listen(4000, () => console.log("üéõÔ∏è Orchestrator escuchando en puerto 4000"));
```

üëâ El orquestador sabe el **workflow completo**, y las dem√°s piezas solo exponen operaciones simples.

---

### ‚úÖ Ventajas de la orquestaci√≥n

* Flujo m√°s **visible y centralizado**.
* Un √∫nico lugar para aplicar **reintentos, compensaciones, logs, timeouts**, etc.
* M√°s f√°cil razonar sobre sagas complejas (por ejemplo, deshacer pasos previos si uno falla).

### ‚ö†Ô∏è Inconvenientes

* Riesgo de crear un **‚Äúmega servicio‚Äù** que se convierte en un nuevo monolito l√≥gico.
* Mayor acoplamiento: todos dependen del orquestador.
* Si el orquestador falla, el flujo completo se ve afectado.

---

## üß† Coreograf√≠a vs Orquestaci√≥n: comparativa

```mermaid
graph TD
  subgraph Coreograf√≠a
    E1[Orders] -->|evento pedido_creado| BUS1[(Event Bus)]
    BUS1 --> P1[Payments]
    P1 -->|evento pago_confirmado| BUS1
    BUS1 --> S1[Shipping]
  end

  subgraph Orquestaci√≥n
    ORC[Orchestrator] --> O2[Orders]
    ORC --> P2[Payments]
    ORC --> S2[Shipping]
  end
```

| Aspecto                 | Coreograf√≠a             | Orquestaci√≥n                         |
| ----------------------- | ----------------------- | ------------------------------------ |
| Control del flujo       | Distribuido             | Centralizado                         |
| Acoplamiento            | Bajo (entre servicios)  | Mayor hacia el orquestador           |
| Visibilidad del proceso | Difusa                  | Clara (un solo punto)                |
| Extensibilidad          | Alta (a√±adir listeners) | Media (hay que tocar el orquestador) |
| Complejidad             | Repartida               | Concentrada                          |

---

## üß© ¬øCu√°ndo usar cada enfoque?

**Coreograf√≠a ‚Äì recomendable cuando:**

* El flujo es **simple** y natural por eventos.
* Quieres minimizar la l√≥gica centralizada.
* Necesitas alta **extensibilidad** (a√±adir m√°s servicios ‚Äúescuchando‚Äù un evento).

**Orquestaci√≥n ‚Äì recomendable cuando:**

* El flujo es complejo, con muchos pasos y posibles compensaciones.
* Necesitas **sagas transaccionales** (deshacer pasos en caso de fallo).
* Quieres tener un punto √∫nico de control y monitoreo del proceso.

En sistemas reales, lo habitual es **combinar ambos**:
algunos flujos se orquestan, otros se coreograf√≠an, e incluso un orquestador puede emitir eventos que otros servicios usen de manera coreografiada.

---

## üîö Conclusi√≥n

* La **coreograf√≠a** favorece la **descentralizaci√≥n y extensibilidad**, pero puede complicar la visibilidad del flujo.
* La **orquestaci√≥n** ofrece **control y claridad**, pero aumenta el acoplamiento hacia el orquestador.
* Elegir uno u otro (o una combinaci√≥n) es una decisi√≥n **de dise√±o arquitect√≥nico**, no solo t√©cnica.

Ambos enfoques son fundamentales para dise√±ar **flujos de negocio distribuidos** en arquitecturas de microservicios modernas.

