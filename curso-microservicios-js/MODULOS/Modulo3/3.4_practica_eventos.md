# 3.4 â€“ ğŸ§ª Laboratorio: Arquitectura basada en eventos (CoreografÃ­a y OrquestaciÃ³n)

---

## ğŸ¯ Objetivos

* Aplicar los conceptos de **mensajerÃ­a distribuida** vistos en el mÃ³dulo 3.
* Comprender de forma vivencial las diferencias entre **coreografÃ­a** y **orquestaciÃ³n**.
* Experimentar con un flujo de negocio distribuido (pedidos â†’ pagos â†’ envÃ­os â†’ notificaciones).
* Observar cÃ³mo **RabbitMQ** actÃºa como bus de eventos entre microservicios.

---

## ğŸ§± Estructura del laboratorio

```
LABS/mensajeria_eventos/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ orchestrator-service/
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ orders-service/
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ payments-service/
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ shipping-service/
â”‚   â””â”€â”€ index.js
â””â”€â”€ notifications-service/
    â””â”€â”€ index.js
```

El laboratorio se divide en **dos fases:**

1. ğŸ•º **CoreografÃ­a:** los servicios se comunican entre sÃ­ mediante eventos RabbitMQ.
2. ğŸ›ï¸ **OrquestaciÃ³n:** un servicio central (`orchestrator-service`) coordina el flujo con llamadas HTTP.

---

## ğŸ³ Paso 1 â€” Crear el entorno Docker Compose

Guarda este archivo como
`LABS/mensajeria_eventos/docker-compose.yml`

```yaml
version: "3.9"

services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"

  orders-service:
    image: node:22
    container_name: orders-service
    working_dir: /app
    volumes:
      - ./orders-service:/app
    command: bash -c "npm install express amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    ports:
      - "3000:3000"
    depends_on:
      - rabbitmq

  payments-service:
    image: node:22
    container_name: payments-service
    working_dir: /app
    volumes:
      - ./payments-service:/app
    command: bash -c "npm install amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    depends_on:
      - rabbitmq

  shipping-service:
    image: node:22
    container_name: shipping-service
    working_dir: /app
    volumes:
      - ./shipping-service:/app
    command: bash -c "npm install amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    depends_on:
      - rabbitmq

  notifications-service:
    image: node:22
    container_name: notifications-service
    working_dir: /app
    volumes:
      - ./notifications-service:/app
    command: bash -c "npm install amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    depends_on:
      - rabbitmq

  orchestrator-service:
    image: node:22
    container_name: orchestrator-service
    working_dir: /app
    volumes:
      - ./orchestrator-service:/app
    command: bash -c "npm install express axios && node index.js"
    ports:
      - "4000:4000"
    depends_on:
      - orders-service
      - payments-service
      - shipping-service
      - notifications-service
```

---

## ğŸ§© Paso 2 â€” Fase 1: CoreografÃ­a por eventos

Los servicios se comunican **Ãºnicamente a travÃ©s de RabbitMQ**.
Cada uno reacciona a un evento y publica el siguiente.

---

### ğŸŸ¢ `orders-service/index.js`

```js
import express from "express";
import amqp from "amqplib";

const app = express();
app.use(express.json());
const PORT = 3000;
const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

app.post("/orders", async (req, res) => {
  const pedido = { id: Date.now(), cliente: req.body.cliente };
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange("eventos", "topic", { durable: true });

  ch.publish("eventos", "pedido.creado", Buffer.from(JSON.stringify(pedido)));
  console.log("ğŸ“¤ Evento 'pedido.creado' emitido:", pedido.id);

  await ch.close();
  await conn.close();
  res.json({ status: "ok", pedido });
});

app.listen(PORT, () => console.log(`ğŸ§¾ Orders Service en puerto ${PORT}`));
```

---

### ğŸ’³ `payments-service/index.js`

```js
import amqp from "amqplib";

const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

(async () => {
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange("eventos", "topic", { durable: true });

  const q = await ch.assertQueue("payments");
  await ch.bindQueue(q.queue, "eventos", "pedido.creado");

  console.log("ğŸ’³ Payments Service escuchando 'pedido.creado'...");

  ch.consume(q.queue, msg => {
    const pedido = JSON.parse(msg.content.toString());
    console.log(`ğŸ’³ Pago realizado para pedido ${pedido.id}`);

    const eventoPago = { pedidoId: pedido.id, cliente: pedido.cliente };
    ch.publish("eventos", "pago.confirmado", Buffer.from(JSON.stringify(eventoPago)));

    ch.ack(msg);
  });
})();
```

---

### ğŸšš `shipping-service/index.js`

```js
import amqp from "amqplib";

const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

(async () => {
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange("eventos", "topic", { durable: true });

  const q = await ch.assertQueue("shipping");
  await ch.bindQueue(q.queue, "eventos", "pago.confirmado");

  console.log("ğŸšš Shipping Service escuchando 'pago.confirmado'...");

  ch.consume(q.queue, msg => {
    const data = JSON.parse(msg.content.toString());
    console.log(`ğŸšš EnvÃ­o preparado para pedido ${data.pedidoId}`);
    const eventoEnvio = { pedidoId: data.pedidoId };
    ch.publish("eventos", "pedido.enviado", Buffer.from(JSON.stringify(eventoEnvio)));
    ch.ack(msg);
  });
})();
```

---

### âœ‰ï¸ `notifications-service/index.js`

```js
import amqp from "amqplib";

const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";

(async () => {
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange("eventos", "topic", { durable: true });

  const q = await ch.assertQueue("notifications");
  await ch.bindQueue(q.queue, "eventos", "pedido.enviado");

  console.log("âœ‰ï¸ Notifications Service escuchando 'pedido.enviado'...");

  ch.consume(q.queue, msg => {
    const data = JSON.parse(msg.content.toString());
    console.log(`âœ‰ï¸ Email enviado al cliente del pedido ${data.pedidoId}`);
    ch.ack(msg);
  });
})();
```

---

### â–¶ï¸ Ejecutar la coreografÃ­a

Desde el Codespace:

```bash
docker compose up
```

Luego crea un pedido:

```bash
curl -X POST http://localhost:3000/orders \
  -H "Content-Type: application/json" \
  -d '{"cliente": "David"}'
```

VerÃ¡s en la consola:

```
orders-service: ğŸ“¤ Evento 'pedido.creado' emitido
payments-service: ğŸ’³ Pago realizado
shipping-service: ğŸšš EnvÃ­o preparado
notifications-service: âœ‰ï¸ Email enviado
```

ğŸ‰ Flujo coreografiado completado sin control central.

---

## ğŸ›ï¸ Paso 3 â€” Fase 2: OrquestaciÃ³n

Ahora aÃ±adiremos el **`orchestrator-service`**, que coordina todo mediante HTTP.

---

### ğŸšï¸ `orchestrator-service/index.js`

```js
import express from "express";
import axios from "axios";

const app = express();
app.use(express.json());

const ORDERS_URL = "http://orders-service:3000";
const PAYMENTS_URL = "http://payments-service:3001";
const SHIPPING_URL = "http://shipping-service:3002";
const NOTIFICATIONS_URL = "http://notifications-service:3003";

app.post("/procesar-pedido", async (req, res) => {
  try {
    const { cliente } = req.body;
    console.log("ğŸ›ï¸ Iniciando flujo orquestado...");

    const pedido = await axios.post(`${ORDERS_URL}/orders`, { cliente });
    await axios.post(`${PAYMENTS_URL}/pagar`, { pedidoId: pedido.data.id });
    await axios.post(`${SHIPPING_URL}/enviar`, { pedidoId: pedido.data.id });
    await axios.post(`${NOTIFICATIONS_URL}/email`, { pedidoId: pedido.data.id });

    res.json({ status: "ok", pedidoId: pedido.data.id });
  } catch (e) {
    console.error("âŒ Error en orquestador:", e.message);
    res.status(500).json({ error: "Fallo en flujo orquestado" });
  }
});

app.listen(4000, () => console.log("ğŸ›ï¸ Orchestrator Service en puerto 4000"));
```

*(Para esta fase, puedes simplificar los otros servicios exponiendo endpoints bÃ¡sicos como `/pagar`, `/enviar`, `/email` que solo impriman logs.)*

---

## ğŸ§ª Paso 4 â€” Pruebas

### ğŸ•º CoreografÃ­a

1. Ejecuta:

   ```bash
   curl -X POST http://localhost:3000/orders -H "Content-Type: application/json" -d '{"cliente": "Ana"}'
   ```
2. Observa el encadenamiento automÃ¡tico por eventos:

   ```
   pedido.creado â†’ pago.confirmado â†’ pedido.enviado â†’ email.enviado
   ```

### ğŸ›ï¸ OrquestaciÃ³n

1. Ejecuta:

   ```bash
   curl -X POST http://localhost:4000/procesar-pedido -H "Content-Type: application/json" -d '{"cliente": "Luis"}'
   ```
2. VerÃ¡s en los logs cÃ³mo el orquestador controla cada paso.

---

## ğŸ“Š Comparativa prÃ¡ctica

| Enfoque          | CoordinaciÃ³n | Canal              | Control central | Ideal para                           |
| ---------------- | ------------ | ------------------ | --------------- | ------------------------------------ |
| **CoreografÃ­a**  | Distribuida  | RabbitMQ (eventos) | No              | Flujos simples, reacciones naturales |
| **OrquestaciÃ³n** | Centralizada | HTTP               | SÃ­              | Flujos complejos, control total      |

---

## ğŸ”š ConclusiÃ³n

En este laboratorio has visto:

* CÃ³mo los microservicios pueden **coordinarse por eventos** (coreografÃ­a).
* CÃ³mo un **orquestador** puede asumir el control de un flujo completo.
* Que ambos enfoques son **complementarios**, no excluyentes.

ğŸ¯ **Aprendizaje clave:**
El diseÃ±o del flujo depende del equilibrio entre **autonomÃ­a** (coreografÃ­a) y **control** (orquestaciÃ³n).