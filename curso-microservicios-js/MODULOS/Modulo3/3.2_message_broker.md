# 3.2 â€“ Patrones de Enrutamiento y PublicaciÃ³n

---

## ğŸ¯ Objetivo

Comprender cÃ³mo los **mensajes** enviados en una arquitectura distribuida pueden **dirigirse selectivamente** a distintos consumidores usando **patrones de enrutamiento**, gestionados por un componente del broker llamado **exchange**.

---

## ğŸ§© Contexto

Hasta ahora, nuestros ejemplos usaban una **cola directa**:
el productor enviaba un mensaje a una cola (`pedidos_creados`) y el consumidor la escuchaba.

Pero los sistemas reales rara vez se limitan a una cola Ãºnica.
Normalmente existen **mÃºltiples consumidores**, **diferentes tipos de eventos**, y **distintas rutas** para esos mensajes.

AhÃ­ es donde entra el **enrutamiento**.

---

## âš™ï¸ Concepto de *Exchange*

Un **exchange** es el punto de entrada del broker que **recibe mensajes de los productores** y decide **a quÃ© colas los envÃ­a**, segÃºn su tipo y reglas.

Cada exchange tiene un **tipo de enrutamiento**, y cada cola se **vincula** a Ã©l mediante una **clave** (*routing key*).

---

## ğŸ§­ Tipos principales de Exchanges

| Tipo        | DescripciÃ³n                                                                                     | Ejemplo de uso                                   |
| ----------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| **direct**  | Entrega mensajes solo a las colas cuya clave coincida exactamente con la clave de enrutamiento. | `pedido.creado`, `pedido.cancelado`              |
| **fanout**  | EnvÃ­a los mensajes a **todas las colas** enlazadas, sin mirar la clave.                         | Broadcast de eventos globales                    |
| **topic**   | Usa patrones con comodines (`*`, `#`) para filtrar mensajes por tema.                           | Enrutamiento jerÃ¡rquico: `pedido.*`, `usuario.#` |
| **headers** | Usa cabeceras del mensaje para decidir el destino (poco comÃºn).                                 | Filtrado avanzado por atributos                  |

---

## ğŸ”¹ Ejemplo 1: Direct Exchange

Supongamos que tenemos dos colas:

* `cola_pedidos_creados`
* `cola_pedidos_cancelados`

Cada una debe recibir solo los mensajes que le correspondan.

### Productor

```js
import amqp from "amqplib";

async function publicador() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const exchange = "pedidos_exchange";
  await ch.assertExchange(exchange, "direct", { durable: true });

  // Publicamos dos tipos de eventos
  ch.publish(exchange, "pedido.creado", Buffer.from("ğŸ§¾ Pedido creado #123"));
  ch.publish(exchange, "pedido.cancelado", Buffer.from("âŒ Pedido cancelado #456"));

  console.log("ğŸ“¤ Mensajes enviados (direct)");
  await ch.close(); await conn.close();
}

publicador();
```

### Consumidores

```js
import amqp from "amqplib";

async function consumidorCreaciones() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "pedidos_exchange";

  await ch.assertExchange(exchange, "direct", { durable: true });
  const q = await ch.assertQueue("cola_pedidos_creados");
  await ch.bindQueue(q.queue, exchange, "pedido.creado");

  console.log("ğŸ“¥ Escuchando pedidos creados...");
  ch.consume(q.queue, msg => {
    console.log("âœ…", msg.content.toString());
    ch.ack(msg);
  });
}

async function consumidorCancelaciones() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "pedidos_exchange";

  await ch.assertExchange(exchange, "direct", { durable: true });
  const q = await ch.assertQueue("cola_pedidos_cancelados");
  await ch.bindQueue(q.queue, exchange, "pedido.cancelado");

  console.log("ğŸ“¥ Escuchando pedidos cancelados...");
  ch.consume(q.queue, msg => {
    console.log("ğŸš«", msg.content.toString());
    ch.ack(msg);
  });
}

consumidorCreaciones();
consumidorCancelaciones();
```

ğŸ‘‰ Resultado:

* `cola_pedidos_creados` solo recibe los mensajes con clave `"pedido.creado"`.
* `cola_pedidos_cancelados` recibe los `"pedido.cancelado"`.

---

## ğŸ”¹ Ejemplo 2: Fanout Exchange (Broadcast)

Este patrÃ³n ignora las claves y envÃ­a cada mensaje a **todas las colas conectadas**.
Es ideal para notificaciones globales o logs.

### Productor

```js
import amqp from "amqplib";

async function publicador() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const exchange = "notificaciones";
  await ch.assertExchange(exchange, "fanout", { durable: false });

  const mensaje = "ğŸ”” NotificaciÃ³n global del sistema";
  ch.publish(exchange, "", Buffer.from(mensaje));

  console.log("ğŸ“¤ Mensaje broadcast enviado");
  await ch.close(); await conn.close();
}

publicador();
```

### Consumidor (cada instancia recibe una copia)

```js
import amqp from "amqplib";

async function consumidor(nombre) {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "notificaciones";

  await ch.assertExchange(exchange, "fanout", { durable: false });
  const q = await ch.assertQueue("", { exclusive: true }); // cola temporal
  await ch.bindQueue(q.queue, exchange, "");

  console.log(`ğŸ“¥ ${nombre} escuchando notificaciones...`);
  ch.consume(q.queue, msg => {
    console.log(`ğŸ’¬ ${nombre}:`, msg.content.toString());
  }, { noAck: true });
}

consumidor("Servicio A");
consumidor("Servicio B");
```

ğŸ‘‰ Resultado:
Ambos consumidores reciben **la misma notificaciÃ³n**.

---

## ğŸ”¹ Ejemplo 3: Topic Exchange (enrutamiento jerÃ¡rquico)

El tipo **topic** permite usar **comodines** en las claves de enrutamiento:

* `*` coincide con una palabra.
* `#` coincide con cero o mÃ¡s palabras.

Esto permite crear flujos muy flexibles.

### Productor

```js
import amqp from "amqplib";

async function publicador() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const exchange = "eventos";
  await ch.assertExchange(exchange, "topic", { durable: false });

  ch.publish(exchange, "pedido.creado", Buffer.from("Nuevo pedido #100"));
  ch.publish(exchange, "pedido.entregado", Buffer.from("Pedido #100 entregado"));
  ch.publish(exchange, "usuario.registrado", Buffer.from("Nuevo usuario: Ana"));

  console.log("ğŸ“¤ Eventos topic publicados");
  await ch.close(); await conn.close();
}

publicador();
```

### Consumidor A (solo pedidos)

```js
import amqp from "amqplib";

async function consumidorPedidos() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "eventos";

  await ch.assertExchange(exchange, "topic", { durable: false });
  const q = await ch.assertQueue("cola_pedidos");
  await ch.bindQueue(q.queue, exchange, "pedido.*");

  console.log("ğŸ“¥ Escuchando eventos de pedidos...");
  ch.consume(q.queue, msg => {
    console.log("ğŸ“¦ Pedido:", msg.content.toString());
    ch.ack(msg);
  });
}

consumidorPedidos();
```

### Consumidor B (todos los eventos del sistema)

```js
import amqp from "amqplib";

async function consumidorGlobal() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();
  const exchange = "eventos";

  await ch.assertExchange(exchange, "topic", { durable: false });
  const q = await ch.assertQueue("cola_global");
  await ch.bindQueue(q.queue, exchange, "#");

  console.log("ğŸ“¥ Escuchando todos los eventos...");
  ch.consume(q.queue, msg => {
    console.log("ğŸ§© Evento:", msg.fields.routingKey, "-", msg.content.toString());
    ch.ack(msg);
  });
}

consumidorGlobal();
```

ğŸ‘‰ Resultado:

* `cola_pedidos` recibe solo eventos `pedido.*`
* `cola_global` recibe **todos los eventos**

---

## ğŸ’¬ CuÃ¡ndo usar cada tipo

| PatrÃ³n     | Ideal para...                      | Ejemplo prÃ¡ctico                                       |
| ---------- | ---------------------------------- | ------------------------------------------------------ |
| **direct** | Rutas exactas (acciones concretas) | `pedido.creado`, `pedido.cancelado`                    |
| **fanout** | Difundir informaciÃ³n general       | â€œSistema en mantenimientoâ€, â€œNueva versiÃ³n disponibleâ€ |
| **topic**  | Filtrar por dominios o jerarquÃ­as  | `pedido.*`, `usuario.#`                                |

---

## ğŸ§  Beneficios del enrutamiento

1. **Desacopla aÃºn mÃ¡s los servicios:** el productor no necesita conocer a los consumidores.
2. **Facilita la extensiÃ³n:** nuevos servicios pueden suscribirse sin tocar el cÃ³digo existente.
3. **Reduce dependencias:** cada consumidor procesa solo lo que le interesa.
4. **Permite broadcasting y segmentaciÃ³n a la vez.**

---

## ğŸ”š ConclusiÃ³n

Los **patrones de enrutamiento** son el corazÃ³n del modelo de mensajerÃ­a distribuida.
Gracias a ellos, podemos construir **arquitecturas event-driven escalables**, donde cada servicio actÃºa como:

* Emisor de eventos (publisher),
* Procesador de eventos (subscriber),
* O ambos.

En el siguiente tema (3.3) exploraremos **cÃ³mo estos eventos pueden transformarse en el nÃºcleo del modelo de datos** mediante los patrones **CQRS y Event Sourcing**, integrando lo aprendido sobre mensajerÃ­a y resiliencia.