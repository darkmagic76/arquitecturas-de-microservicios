# 3.1 â€“ IntroducciÃ³n a la MensajerÃ­a Distribuida

---

## ğŸ¯ Objetivo

Comprender el papel de la **mensajerÃ­a distribuida** dentro de una arquitectura de microservicios, y cÃ³mo los servicios pueden comunicarse **de manera asÃ­ncrona** usando *message brokers* como **RabbitMQ o Kafka** para desacoplar procesos, mejorar la resiliencia y escalar el sistema de forma mÃ¡s eficiente.

---

## ğŸ§© Contexto

En los temas anteriores vimos cÃ³mo los servicios pueden comunicarse entre sÃ­ de forma **sÃ­ncrona** (REST, HTTP).
Ese modelo es Ãºtil, pero tiene una limitaciÃ³n:

> cuando un servicio falla, **todo el flujo se detiene**.

La **mensajerÃ­a distribuida** surge como respuesta a ese problema: los servicios dejan de depender de la disponibilidad inmediata de otros y se comunican **a travÃ©s de mensajes**, de manera **asÃ­ncrona y desacoplada**.

---

## âš™ï¸ Concepto de mensajerÃ­a distribuida

En este modelo, los servicios no se llaman directamente.
En su lugar:

1. **Un servicio publica un mensaje** (por ejemplo, â€œpedido_creadoâ€) en un intermediario.
2. **El broker almacena y distribuye** ese mensaje de forma fiable.
3. **Otros servicios suscritos** lo reciben y lo procesan cuando estÃ©n disponibles.

Este intermediario se llama **message broker**.
Ejemplos populares:

* ğŸ‡ **RabbitMQ**
* ğŸ¦ **Kafka**
* â˜ï¸ **Amazon SQS**
* ğŸ”· **Azure Service Bus**

---

## ğŸ”— Ventajas frente a REST

| Aspecto                    | REST (sÃ­ncrono)                               | MensajerÃ­a (asÃ­ncrono)             |
| -------------------------- | --------------------------------------------- | ---------------------------------- |
| **Acoplamiento temporal**  | Alto (debe estar disponible el otro servicio) | Bajo (se puede procesar mÃ¡s tarde) |
| **Tolerancia a fallos**    | Baja                                          | Alta                               |
| **Latencia**               | Inmediata                                     | Diferida                           |
| **Escalabilidad**          | Limitada                                      | Natural (procesos en paralelo)     |
| **Modelo de comunicaciÃ³n** | PeticiÃ³n â†’ Respuesta                          | PublicaciÃ³n â†’ SuscripciÃ³n          |

---

## ğŸ§± Arquitectura bÃ¡sica

```
[Productor] â†’ (Publica mensaje) â†’ [Broker de Mensajes] â†’ (Entrega) â†’ [Consumidor]
```

Cada mensaje representa un **evento de negocio**.
Ejemplo:

* `pedido_creado`
* `usuario_registrado`
* `producto_actualizado`

---

## ğŸ§© Ejemplo funcional con RabbitMQ

Imaginemos un flujo de **pedidos y facturaciÃ³n**:

* El servicio `orders` crea un pedido y **publica un evento** `pedido_creado`.
* El servicio `billing` **escucha ese evento** y genera una factura.

Asumiremos que el broker RabbitMQ ya estÃ¡ funcionando (puede estar definido en `docker-compose.yml`).

---

### ğŸ‡ Productor â€“ Servicio de Pedidos

```js
import amqp from "amqplib";

async function publicarPedido(pedido) {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const cola = "pedidos_creados";
  await ch.assertQueue(cola, { durable: true });

  const mensaje = JSON.stringify(pedido);
  ch.sendToQueue(cola, Buffer.from(mensaje));

  console.log(`ğŸ“¤ Pedido publicado: ${pedido.id}`);
  await ch.close();
  await conn.close();
}

// SimulaciÃ³n de creaciÃ³n de pedido
const nuevoPedido = { id: Date.now(), user: "Ana", total: 42.9 };
publicarPedido(nuevoPedido);
```

---

### ğŸ’° Consumidor â€“ Servicio de FacturaciÃ³n

```js
import amqp from "amqplib";

async function escucharPedidos() {
  const conn = await amqp.connect("amqp://rabbitmq");
  const ch = await conn.createChannel();

  const cola = "pedidos_creados";
  await ch.assertQueue(cola, { durable: true });

  console.log("ğŸ“¥ Esperando eventos de 'pedidos_creados'...");

  ch.consume(cola, msg => {
    const pedido = JSON.parse(msg.content.toString());
    console.log(`ğŸ§¾ Generando factura para pedido ${pedido.id} (${pedido.user})`);
    ch.ack(msg);
  });
}

escucharPedidos();
```

---

### ğŸ” QuÃ© observamos aquÃ­

* El **servicio de pedidos no depende del de facturaciÃ³n**.
  Publica el mensaje y sigue trabajando.
* Si `billing` estÃ¡ caÃ­do, el mensaje **permanece en la cola** hasta que se reconecte.
* Es posible tener **mÃºltiples consumidores** escuchando la misma cola o distintas.

ğŸ‘‰ Con esto hemos logrado **desacoplar temporalmente los servicios**.

---

## ğŸ§  Conceptos clave

| Concepto                    | DescripciÃ³n                                                              |
| --------------------------- | ------------------------------------------------------------------------ |
| **Productor (Publisher)**   | EnvÃ­a mensajes al broker.                                                |
| **Consumidor (Subscriber)** | Recibe y procesa mensajes.                                               |
| **Cola (Queue)**            | Estructura FIFO donde se almacenan los mensajes hasta ser consumidos.    |
| **Exchange (enrutador)**    | Componente que distribuye mensajes segÃºn reglas (fanout, direct, topic). |
| **Acknowledgment (ack)**    | ConfirmaciÃ³n de que un mensaje fue procesado con Ã©xito.                  |

---

## ğŸ•¸ï¸ Modos de enrutamiento comunes

| Tipo de Exchange | DescripciÃ³n                                   | Ejemplo de uso                      |
| ---------------- | --------------------------------------------- | ----------------------------------- |
| **fanout**       | EnvÃ­a el mensaje a todas las colas enlazadas. | Broadcast de eventos globales.      |
| **direct**       | Usa una clave de enrutamiento exacta.         | Un mensaje va a una cola concreta.  |
| **topic**        | Usa patrones de enrutamiento (comodines).     | Filtrar eventos por tipo o dominio. |

Ejemplo con *topic*:

```js
ch.publish("eventos", "pedido.creado", Buffer.from(JSON.stringify(pedido)));
```

---

## ğŸ§© IntegraciÃ³n con patrones de resiliencia

La mensajerÃ­a se complementa perfectamente con los patrones vistos antes:

| PatrÃ³n              | CÃ³mo se combina                                                             |
| ------------------- | --------------------------------------------------------------------------- |
| **Retry**           | RabbitMQ puede reintentar automÃ¡ticamente entregar mensajes.                |
| **Timeout**         | Los consumidores pueden limitar su tiempo de procesamiento.                 |
| **Circuit Breaker** | Si el broker estÃ¡ caÃ­do, el publicador corta la comunicaciÃ³n temporalmente. |
| **Fallback**        | Si no se puede enviar el mensaje, se guarda en una â€œcola de esperaâ€ local.  |

---

## ğŸ”§ Comparativa prÃ¡ctica: REST vs MensajerÃ­a

| SituaciÃ³n                           | REST (SÃ­ncrono)                   | RabbitMQ (AsÃ­ncrono)                                 |
| ----------------------------------- | --------------------------------- | ---------------------------------------------------- |
| El servicio destino estÃ¡ caÃ­do      | La peticiÃ³n falla                 | El mensaje se encola y se procesarÃ¡ mÃ¡s tarde        |
| Escalado horizontal                 | Complejo, necesita load balancing | Natural, los consumidores pueden aumentar            |
| AuditorÃ­a de eventos                | Requiere logs externos            | El broker conserva trazabilidad de mensajes          |
| CoordinaciÃ³n entre varios servicios | Multiplica las llamadas           | Cada servicio se suscribe a los eventos que necesita |

---

## ğŸ’¬ AnalogÃ­a

> Imagina que REST es **una llamada telefÃ³nica**:
> necesitas que la otra persona te conteste ahora mismo.
>
> En cambio, la mensajerÃ­a es **como enviar un correo electrÃ³nico**:
> lo mandas, queda entregado al buzÃ³n, y el receptor lo leerÃ¡ cuando pueda.
>
> AsÃ­ logras **desacoplar el tiempo** de emisiÃ³n y recepciÃ³n.

---

## ğŸ”š ConclusiÃ³n

La mensajerÃ­a distribuida representa un **cambio de paradigma**:
los servicios dejan de comunicarse â€œcara a caraâ€ y comienzan a hacerlo **por eventos**.

Esto permite:

* Tolerar fallos sin interrupciones.
* Escalar consumidores segÃºn demanda.
* Implementar flujos complejos mediante **event-driven architectures**.

En los siguientes apartados (3.2 y 3.3) veremos cÃ³mo diseÃ±ar **flujos event-driven** reales,
y cÃ³mo aplicar **patrones CQRS y Event Sourcing** para aprovechar esta infraestructura de mensajerÃ­a.